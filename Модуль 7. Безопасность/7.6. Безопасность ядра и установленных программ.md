
## **Виды уязвимостей**

Уязвимости делят на три категории:

- Уязвимости проектирования — самые сложно устранимые. Это недостатки на уровне алгоритмов работы программы, на основе которых потом пишется код.
- Уязвимости реализации — это как раз те, которые появляются в процессе написания кода, например, синтаксические дефекты.
- Уязвимости конфигурации — это недочёты, возникающие при установке и настройке программы. Их устранить проще всего, но они как раз часто встречаются однотипные.

С последними, уязвимостями конфигурации, мы как системные администраторы имеем дело. Мы меняем настройки по умолчанию, устанавливаем сложные пароли, ограничиваем доступ к функциям.

Но если уязвимости конфигурации мы можем если не устранить насовсем, то, хотя бы, максимально сгладить, то уязвимости реализации и, тем более, проектирования, подвластны только разработчикам программ.

## **Уязвимости реализации**

Есть переменная, которая может занимать ограниченное пространство в памяти. И есть функция, которая записывает значение в эту переменную — но у этой функции нет ограничений. Хакер вводит в эту функцию огромное значение, функция его передаёт в переменную, переменная не может уместить такое большое значение в отведённую под переменную память.

Самые частые последствия бывают двух видов: либо функция или вся программа аварийно завершают работу (**и это типичный** _**DoS**)_ либо, ещё хуже, значение продолжает писаться в память за пределами переменной. Почему хуже? Как вариант — потому что где заканчивается переменная, начинается что-то ещё, в том числе потенциально важные системные данные.

Ещё одна похожая атака — **инъекции**, особенно популярны _SQL_-инъекции. Принцип примерно тот же, использовать валидную возможность ввести значение (например, в поле в анкете на каком-то сайте) такого вида, что оно само будет какой-то функцией или запросом _SQL_ (то есть к базе данных).

Если не предусмотрены проверки таких значений, и программа их пропустит, эти функции, запускаясь, могут управлять программой или, в случае _SQL_, её базой данных.

**Эскалация привилегий** — другой пример атаки, который почти всегда имеет место в масштабном взломе. Чтобы действительно нанести масштабный вред всей сети, хакер должен получить максимальный доступ ко всем службам — то есть переходить от доступа обычного пользователя к администратору (или, в случае _Linux_, к доступу уровня _root_). Один из примеров того, как это может быть — при определённых настройках команда `sudo -i` от _sudoers_-пользователя, не запрашивая пароля, залогинит вас как пользователя _root_.

## **Как настроить автоматическую установку обновлений безопасности**

В _Linux_ можно настроить, конечно, и обновление всех пакетов регулярно до самой последней версии, но это уже вопрос личных предпочтений.

А вот для того, чтобы устанавливать автоматически только обновления безопасности, можно использовать пакет _unattended-upgrades_.

После установки (пакетным менеджером, как обычно), в папке `/etc/apt/apt.conf.d/` нам нужны файлы, содержащие в названии _auto-upgrades_ и _unattended-upgrades_.

Файл `/etc/apt/apt.conf.d/50unattended-upgrades` нужен для того, чтобы настроить, какие именно пакеты будут обновляться, а файл `/etc/apt/apt.conf.d/20auto-upgrades` — для указаний, как часто.

В первом нам нужно обозначить, что мы хотим подключить именно автоматическую установку обновлений безопасности. Такие обновления берутся из _security_-репозитория, и обозначаться в этом конфиге могут по-разному. Вот пара примеров для _deb_-систем:

Unattended-Upgrade::Allowed-Origins {
        "${distro_id}:${distro_codename}-security";
};

Unattended-Upgrade::Origins-Pattern {
        "origin=Debian,codename=${distro_codename},label=Debian-Security";
};

Какой выбрать? В файле _50unattended-upgrades_, какой он есть по умолчанию, будет закомментирована нужная строчка, заканчивающаяся на _-security_, её нужно будет только раскомментировать.

Ещё мы можем запретить определённым пакетам автообновления — даже если они во имя безопасности. Для пакета _kernel_, например, такое исключение будет выглядеть вот так:

Unattended-Upgrade::Package-Blacklist {
   "kernel";
};

После того, как мы настроили все необходимое в `/etc/apt/apt.conf.d/50unattended-upgrades`, нужно переходить к `/etc/apt/apt.conf.d/20auto-upgrades`. Тут нас, к сожалению, не будут ждать подсказки, но типичная конфигурация, которую вы можете использовать в этом файле, выглядит вот так:

APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Download-Upgradeable-Packages "1";
APT::Periodic::AutocleanInterval "7";
APT::Periodic::Unattended-Upgrade "1";

Цифры 1 и 7 означают периодичность в днях. Меняя эти значения, мы можем приказать автообновлениям происходить чаще или реже.

В данном случае:

- _Update-Package-Lists_ — обновление списка пакетов репозитория (делается раз в день).
- _Download-Upgradeable-Packages_ — скачивание возможных обновлений (тоже раз в день).
- _AutocleanInterval_ — удаление устаревших, ничем не используемых пакетов (раз в неделю).
- _Unattended-Upgrade_ — собственно, автоматическое обновление (каждый день).

Чтобы проверить, как работает автообновление, можно запустить его в _dry-run_ режиме — этот режим применяется для проверки всех шагов, но без выполнения реальных действий (например, в нашем случае, он проверит все конфиги и репозитории, но реально обновлять пакеты не будет):

unattended-upgrade -v -d --dry-run

Автоустановка обновлений безопасности — это важный шаг настройки системы. Даже если вы уверены, что будете каждую неделю вручную устанавливать все нужные обновления, никто не гарантирует, что эту традицию продолжит ваш приемник или что критическая уязвимость не появится в тот момент, когда вы уехали в заслуженный отпуск.

