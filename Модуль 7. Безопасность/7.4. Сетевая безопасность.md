
## **Порты и протоколы**

Например, то, что нам, может, и хотелось бы, как инженерам по безопасности, закрыть вообще все порты. Но если у нас веб-сервер работает, то без открытых портов 80 и 443 он пользователю сайт не покажет. И если мы 80 и 443 закроем вместе с остальными, то работа веб-сервера, фактически, встанет. Об этом мы с вами уже говорили в прошлом модуле — что надо закрывать порты, которые не используются, и открывать те, которые используются, фаерволом.

И в прошлых юнитах начали разбирать закрытие доступа для всех _IP_-адресов, кроме одного. Вспомним, как это делается:

iptables -A INPUT -p tcp --dport 22 -s 2.2.2.2 -j ACCEPT
iptables -A INPUT -p tcp --dport 22 -j REJECT

Таким же образом можно разрешить доступ нескольким _IP_-адресам и запретить всем остальным.

Вот, например, 22 порт — это порт _SSH_, как мы уже знаем. А по какому протоколу _SSH_ работает? Вообще, по _TCP_. То есть, казалось бы, _UDP_-порт 22 мы можем смело закрывать.

В целом, это правда, но, например, есть протокол _FASP_, который использует _SSH_ по 22 _UDP_-порту. Если вдруг когда-то вы с ним встретитесь, то, скорее всего, не сразу дойдёте до мысли, что он использует _UDP-SSH_. В требованиях, скорее всего, будет просто указан _SSH_, без уточнений, и вы будете биться об эту проблему, пока не нагуглите специфику.

Но если с _UDP_ всё неоднозначно, то проще с _ICMP_. _ICMP_ — это протокол пинга, утилиты, проверяющей, реагирует ли вообще сервер на внешние раздражители.

Если сервер отвечает на пинг, его удобно проверять что вам, что потенциальным злоумышленникам. В том числе проверять все открытые порты. Это вроде того, что мы детей учим «если в дверь позвонят, не говори, что ты дома один». Тут хорошей практикой считается закрыть _ICMP_ для главных боевых серверов, и оставить открытым для любых тестовых и внутренних.

Запретить пинговать свой сервер при помощи _iptables_ можно следующим образом:

iptables -I INPUT -p icmp --icmp-type 8 -j DROP

