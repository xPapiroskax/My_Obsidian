
Контейнеризация — это метод виртуализации, при котором ядро операционной системы поддерживает несколько изолированных экземпляров пространства пользователя вместо одного. Эти экземпляры (обычно называемые контейнерами или зонами) с точки зрения выполняемых в них процессов идентичны отдельному экземпляру операционной системы.

Самая первая и очевидная проблема, которая решается с помощью контейнеризации — возможность запускать множество приложений изолированно друг от друга, но в тоже время используя один сервер.

На помощь пришла виртуализация, позволив сократить операционные расходы и сгрупировать ресурсы утилизируя их более гибко. Но и этого было недостаточно, так как по прежнему часть ресурсов утилизировалось на _hypervisor_, требовались сложные системы виртуализации и оркестрации самих виртуальных сред. Контейнеризация выглядит как логичное развитие виртуализации, позволяющая нативно,через ядро и механизмы системы, разделять ресурсы и управлять ими.

**2**Вторая, не менее важная проблема — повторяемость. Проведя эксперимент, создав некую экосистему, хочется в точности воспроизвести её некоторое количество раз, описав разворачивание в виде инструкций и быть уверенным в конечном результате. Подобное поведение называют [идемпотентностью](https://ru.wikipedia.org/wiki/%D0%98%D0%B4%D0%B5%D0%BC%D0%BF%D0%BE%D1%82%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C) — способностью при нескольких запусках получать тот же самый результат.

Третья по порядку, но не по значительности проблема — простота использования. Благодаря удобным инструментам, таким как _Docker_ и _Docker-compose_ (о них мы поговорим немного позже), технология завоевала миллионы поклонников и весьма быстро стала стандартом в мире разработки. Разработчикам больше не требуется знать различные операционные системы, заботиться о совместимости библиотек и изоляции ресурсов — всё это делает _Docker_.

Основная идея _Docker_ — разворачивание службы, которая помогает транслировать команды в понятные для ядра вызовы и управлять контейнеризацией, предоставляя пользователю удобный интерфейс и автоматизируя большую часть рутины. Для этого были созданы различные абстракции и инструкции, такие как _docker image, dockerfile_ или реестр образов (_registry_).

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/aad7c8ac69600cafff3f24cc6cef3ab6/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/ADMIN_m19_u2_1.png)

Сам докер-образ — это не что иное, как набор инструкций, описанных в dockerfile, записываемый слоями и позволяющий переиспользовать их, если не вносились изменения, что существенно ускоряет процесс сборки, экономит место и уменьшает число ошибок.

![](https://lms-cdn.skillfactory.ru/assets/courseware/v1/bbecf83fcedabdd58d2199e03800c753/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/admin-19-2-2.png)

Возникает вопрос: как же _Docker_ может работать и на _Unix_-системах, и в _Windows_-среде? 

В основе образов используется файловая система [Aufs](https://ru.wikipedia.org/wiki/Aufs), которая поддерживает как _Unix_-пути (например /opt или /var), так и _Windows_-пути (\Users\home\), что позволяет работать с различными образами, на различных операционных системах, монтируя все каталоги в свои виртуальные.

Используя контейнеризацию, по сравнению с виртуальными машинами, мы имеем огромное преимущество: ресурсы контейнера тратятся только на решение функциональной задачи контейнера. Из этого вытекает плюс в виде экономии системных ресурсов и простоты переноса, скорости разворачивания, возможности развернуть образ в любой среде (включая _Windows_).

Давайте для начала разберёмся с используемыми терминами:

- **Docker engine** — служба, обеспечивающая работу приложения, работу контейнеров и взаимодействие с пользователями.
- **Docker контейнер** — единица _Docker_, среда в которой выполняется необходимое приложение. Может взаимодействовать с внешним миром по сети и через общие директории с хостом.
- **Docker образ** — набор инсталляционных пакетов и программных инструкций, на основании которых формируется контейнер.
- **Docker Volume** — ключевое слово при создании контейнера, определяет общую директорию между хостом и контейнером (и, следовательно, между несколькими контейнерами, если необходимо).
- **DockerHub** — публичное хранилище для образов. Сайт, на который можно выложить ваш образ, чтобы он был для вас всегда доступен. Также его можно сделать публичным, чтобы он был доступен всем (что мы и сделаем в одном из следующих юнитов).
- **Реестр** (_Registry_) — непубличная реализация _DockerHub_, то есть сервис, развёрнутый в локальной сети, чтобы у узлов в этой сети была возможность скачать и использовать образ. Например, там может быть рабочая среда для разработчиков.
- **Окружение** — компоненты операционной системы или сторонних приложений, с которыми взаимодействует наша система. Например, когда видеопроигрыватель не может проиграть видео, ссылаясь на то, что ему не хватает кодека, мы говорим о необходимости настройки окружения, то есть установки кодека, который не часть файла с видео и не часть проигрывателя, но необходим, чтобы файл можно было проиграть.

# Docker Compose



