
В юните 1 рассказывалось про модели _OSI_ и _TCP/IP_.  Вы узнали, что на определённых уровнях они работают с определёнными протоколами и портами. Какие протоколы и порты часто используются и с какими вы сталкиваетесь каждый день, мы поговорим сейчас.

**Сетевой протокол** — это набор правил и технических процедур, позволяющий компьютерам, объединённым в сеть, осуществлять соединение и обмен данными.

**Порт** — это расширение, которое дополняется к сетевому адресу. Это число, целое и не отрицательное, которое записывается в заголовках протоколов транспортного уровня модели _OSI_, и это число используется для процесса, который получает пакет. Например, _IP_-адрес — это как название улицы, а порт — это как номер дома. 

**Рассмотрим на более понятном примере**.

Вы пользуетесь электронной почтой, и у вас на компьютере установлен почтовый клиент. Этот почтовый клиент отправляет и получает письма, и он является отдельным процессом.

Когда запускается этот процесс, то он должен принимать почту по протоколу, например, _POP_. По умолчанию этот протокол должен слушать порт _TCP_ с номером 110. И если процесс не запущен, то этот протокол не будет работать, не откроет порт 110 и, соответственно, не будет получать почту.

Точное **число сетевых портов** — 65 535. Они могут быть заняты какими-либо протоколами, прописанными и выделенными для конкретных целей, и зарегистрированными _IANA_ (_Internet Assigned Numbers Authority_), что является функцией управления пространствами адресов и доменов, и исполняется компанией _Public Technical Identifiers_, которая находится под контролем _ICANN_ (_Internet Corporation for Assigned Names and Numbers,_ корпорацией по управлению доменными именами и _IP_-адресами). Либо порты могут назначаться для процессов непосредственно администраторами. Порты с номерами до 1023 считаются в _Linux_ критически важными, а порты от 1024 до 49151 являются **пользовательскими**, или **зарегистрированными**. Порты же от 49152 до 65535 являются **динамическими**, или **частными**. 

## **Основные протоколы**

1  

## **Протокол ICMP (Internet Control Message Protocol)**

Протокол межсетевых управляющих сообщений используется для диагностики сетевых неисправностей.

Такие утилиты, как _ping_ и _tracepath_, относятся к этом протоколу. Рассмотрим протокол на примере этих утилит.

Утилита _ping_ проверяет доступность удаленного узла. Команда `ping` отправляет сообщение узлу и ждёт получения ответа от него. Она отправляет серию _ICMP_-сообщений, а получает эхо-ответ. По сути, отправляется сообщение _ECHO_REQUEST_ и должен получить ответ _ECHO_RESPONSE_.

Для примера попробуем попинговать сайт **www.skillfactory.ru**.

root@localhost:~#  ping www.skillfactory.ru
PING www.skillfactory.ru (185.165.123.206) 56(84) bytes of data.
64 bytes from 185.165.123.206 (185.165.123.206): icmp_seq=1 ttl=60 time=0.609 ms
64 bytes from 185.165.123.206 (185.165.123.206): icmp_seq=2 ttl=60 time=0.734 ms
64 bytes from 185.165.123.206 (185.165.123.206): icmp_seq=3 ttl=60 time=0.776 ms
64 bytes from 185.165.123.206 (185.165.123.206): icmp_seq=4 ttl=60 time=0.653 ms
64 bytes from 185.165.123.206 (185.165.123.206): icmp_seq=5 ttl=60 time=0.643 ms
64 bytes from 185.165.123.206 (185.165.123.206): icmp_seq=6 ttl=60 time=0.662 ms

Такое сообщение будет означать, что **www.skillfactory.ru** доступен, утилита _ping_ отправляет пакеты размером 64 байта, получает ответ от 185.165.123.206, что является адресом сервера, на котором расположен сайт.

`icmp_seq` — это номер запроса `ttl` — это _time-to-live_, о котором мы говорили в прошлом юните, `time` — время ответа.

Сайты же работают с протоколами _HTTP_ и _HTTPS_.

2  

## **_HTTP_** (_HyperText Transfer Protocol)_

Протокол передачи гипертекста — протокол передачи данных, который предназначен для передачи гипертекстовых документов. Этот протокол использует клиент-серверную архитектуру.

Т.е. на вашем компьютере формируется запрос по определенному имени которое резолвится в _IP_-адрес (4 юнит, _DNS_), а на стороне сервера работает служба _HTTPD_, которая прослушивает порт под номером 80. На этот порт и отправляется запрос, и он выдает требуемую информацию, и у вас в браузере открывается нужный сайт.

В соответствии со спецификацией модели _OSI_, этот протокол является протоколом 7 уровня (прикладной уровень, _Application Layer_).

Задача протокола — обмен данными между пользовательским приложением, т.е. браузером, и веб-сервером.

3  

## **HTTPS** (_HyperText Transfer Protocol Secure)_

Защищённый протокол передачи гипертекста — это расширение протокола _HTTP_ с поддержкой шифрования для повышения безопасности обмена данными между клиентом и сервером, которые передаются поверх дополнительных криптографических протоколов _TLS_ или _SSL_. И в отличии от _HTTP_, работает он на 443 порту.

Когда браузер делает запрос к сайту, то этому запросу приходится проходить длинный путь через сети, где каждая может быть использована для прослушивания или врезки в соединение, а по этому протоколу могут передаваться и личные данные, такие как почта, пароли и много чего ещё. Поэтому требуются дополнительные меры для защиты такой информации.

Для этого используется протокол TLS.

4  

## **Протокол TLS**

Расположен на уровень ниже протокола _HTTP_ (уровень представления, _Presentation Layer_). Т.е. при формировании запроса он дополнительно шифруется этим протоколом.

_TLS_ — это криптографическая система, которая использует несколько криптографических подходов, такие как симметричное и асимметричное шифрование.

Т.е. поверх запроса накладывается криптография, которая не позволяет злоумышленникам считывать данные, т.к. ключи от неё находятся только у вас и у сервера, на котором работает сайт.

Но криптография — это отдельная тема информационной безопасности, и если изучать её подробно, то это займёт крайне много времени, и в этом модуле углубляться не будем.

Мы уже обсуждали _DNS_ в этом модуле, и он, кстати, тоже работает по отдельному протоколу.

5  

## **_DNS_**

Этот протокол работает на 53 порту. Принцип работы вы уже знаете. Рассмотрим, как можно проводить диагностику.

Для диагностики можно использовать утилиту _dig_.

root@localhost:~# dig адрес_назначения

Например, чтобы посмотреть, какой адрес использует сайт **www.skillfactory.ru**:

root@localhost:~#  dig www.skillfactory.ru

; <<>> DiG 9.16.1-Ubuntu <<>> www.skillfactory.ru
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 19562
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 65494
;; QUESTION SECTION:
;www.skillfactory.ru.           IN      A

;; ANSWER SECTION:
www.skillfactory.ru.    4903    IN      A       185.165.123.206

;; Query time: 0 msec
;; SERVER: 127.0.0.53#53(127.0.0.53)
;; WHEN: Sun Nov 08 17:18:25 MSK 2020
;; MSG SIZE  rcvd: 64

Где будет дан ответ в _ANSWER SECTION_, что адрес — 185.165.123.206.

C помощью этой утилиты можно получать много информации о разных записях, но углубляться в это будем позже, в других модулях.

6  

## **SSH**

Ещё один протокол, который важно упомянуть, — _Secure Shell_ (безопасная оболочка) — широко используемый протокол транспортного уровня для защиты соединений между клиентами и серверами. По умолчанию он работает на 22 порту, но принято всегда изменять порт для этого подключения в связи с безопасностью.

Для подключения к серверам вам постоянно придётся пользоваться этим протоколом. Для этого используются специальные клиенты, либо можно работать с утилитой _ssh_ в командной строке

Рассмотрим на примере. Есть сервер с _IP_-адресом 10.1.2.113, к которому можно подключиться через логин _worker_. Тогда синтаксис будет такой:

root@localhost:~# ssh worker@10.1.2.113

После того как он предложит сверить ключ, согласитесь. Это называется **обмен ключами**.

В процессе обмена ключами (иногда называемого _KEX_) стороны обмениваются общедоступной информацией и выводят **секрет**, совместно используемый клиентом и сервером. Этот секрет невозможно обнаружить или получить из общедоступной информации. После потребуется ввод пароля для пользователя _worker_, затем после авторизации и аутентификации удастся войти в систему.

Как уже было сказано, зачастую порты для _SSH_ в целях безопасности отличаются от дефолтных. Тогда требуется указывать нужный порт через ключ `-p`.

root@localhost:~# ssh worker@10.1.2.113 -p 22

После подключения по _SSH_ вы сможете полноценно работать в другой системе.

_SSH_ позволяет безопасно передавать в незащищённой среде любые другие сетевые протоколы — файлы, видео и пр. К слову, для этого можно использовать _SCP_ — это утилита для копирования файлов по протоколу SSH.

Например, есть пользователь _worker_, у которого в домашней директории лежит файл _file1_, и вам нужно скопировать его на сервер с адресом 10.1.2.2. Скопировать требуется для аналогичного пользователя _worker_ на удалённом сервере, в аналогичную же директорию.

Для этого будет использован синтаксис:

root@localhost:~# scp /home/worker/file1 worker@10.1.2.2:/home/worker

Как уже говорилось, может случиться, что для _SSH_ используется другой порт, а не порт по умолчанию. Например 2048. Для этого надо указать ключ `-P` для нужного порта.

root@localhost:~# scp -P 2048 /home/worker/file1 worker@10.1.2.2:/home/worker

Аналогично можно копировать данные с удалённого сервера, как и в случае с _cp_, меняя место отправления и назначения, копируя на локальную машину. Синтаксис будет такой:

root@localhost:~# scp -P 2048 worker@10.1.2.2:/home/worker/file1  /home/worker/file 

Для передачи данных можно также использовать и протокол _FTP_.

7  

## **FTP** (_File Transfer Protocol_)

FTP — это протокол передачи файлов по сети.

Для работы этого протокола требуется, что бы на машине был поднят _FTP_-сервер, который предусматривает возможность использования протокола передачи файлов. Для передачи данных необходима аутентификация пользователей. Стандартно этот протокол работает на 21 порту, но для безопасности этот порт часто меняют на другие порты. Но т.к. для передачи данных по _FTP_ требуется отдельная настройка и установка сервера и клиентского приложения, мы будем его рассматривать в рамках других модулей, где будет рассказано, как поднимать _FTP_-сервер.

8  

## **ARP** (_Address Resolution Protocol_)

**ARP** — протокол определения адреса) — протокол, предназначенный для определения _MAC_-адреса по _IP_-адресу удалённого устройства.

ARP состоит из двух частей. Первая — определяет физический адрес при посылке пакета, вторая — отвечает на запросы других станций

Для просмотре _ARP_-таблицы в _Linux_ используется команда `arp`.

root@localhost:~#  arp
Address                  HWtype  HWaddress           Flags Mask            Iface
10.1.2.5                 ether   00:1b:21:99:22:ec   C                     ens160
10.1.2.6                 ether   b4:96:91:0f:3a:1e   C                     ens160
10.1.2.3                 ether   00:50:56:ab:d3:16   C                     ens160

Она выведет _MAC_-адреса устройств, к которым вы обращались. Существует утилита, которая позволяет видеть все открытые порты, и какие процессы на них работают. Это утилита _netstat_:

root@localhost:~# netstat 

Для просмотра портов используются ключи:

- `-l` или `--listening` — посмотреть только прослушиваемые порты;
- `-p` или `--program` — показать имя программы и её _PID_;
- `-t` или `--tcp` — показать _TCP_-порты;
- `-u` или `--udp` показать _UDP_-порты;
- `-n` или `--numeric` показывать _IP_-адреса в числовом виде.

Рассмотрим пример вывода:

root@localhost:~#  netstat -tulpn
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      797/systemd-resolve
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      878/sshd: /usr/sbin
tcp6       0      0 :::80                   :::*                    LISTEN      883/apache2
tcp6       0      0 :::22                   :::*                    LISTEN      878/sshd: /usr/sbin
udp        0      0 127.0.0.53:53           0.0.0.0:*                           797/systemd-resolve

В примере видно, что в данный момент в системе открыты и используются порты 53 для _DNS_, 22 порт для подключения по _SSH_, на 80 порту крутится _apache2_ — сервис для _HTTP_. Также отдельно указываются протоколы — _UDP_ и _TCP_. И какую версию они используют — 4 или 6.

Иногда требуется проверить доступность портов на удалённом сервере. В этом может помочь утилита _nmap_, которая позволяет сканировать сеть. Она не идёт из коробки в комплекте с операционной системой, по этому её надо установить через:

root@localhost:~# sudo apt install nmap

И принять подтверждение для установки.

Сама по себе утилита имеет широкий набор инструментария, но для сканирования портов на определённом устройстве можно использовать такой простой синтаксис:

root@localhost:~# nmap ip_address

Либо можно просканировать порты на своей машине, добавив название интерфейса. Например, просканируем порты локального интерфейса машины:

root@localhost:~#  nmap localhost
Starting Nmap 7.80 ( https://nmap.org ) at 2020-11-19 23:11 MSK
Nmap scan report for lo0 (69.46.24.166)
Host is up (0.15s latency).
rDNS record for 69.46.24.166: mail.baraban.com
Not shown: 993 filtered ports
PORT      STATE  SERVICE
22/tcp    open   ssh
25/tcp    closed smtp
80/tcp    open   http
443/tcp   closed https
465/tcp   closed smtps
587/tcp   closed submission
Nmap done: 1 IP address (1 host up) scanned in 17.18 seconds

Будут выведены порты, которые видны, а также время, за которое было выполнено сканирование. Слева, в _PORT_, указываются порты, которые слушаются. _STATE_ показывает, открыт порт или закрыт, а _SERVICE_ указывают ту службу, которая на них работает.

## **Подведём итог**

В этом юните разбиралось, как работают сетевые порты и протоколы, и как ими можно управлять. Вам придётся с этим часто сталкиваться.

Иногда, помогая настраивать людям, которые не очень сильно разбираются в сетях, вы станете обнаруживать, что основная проблема бывает в том, что когда они что-то настроили по статье, но забыли открыть порт, и из-за этого сайты не отображаются, т.к. порт заблокирован и никто не может на него попасть.

## ![рис](https://lms-cdn.skillfactory.ru/assets/courseware/v1/b3d8bf580ab2fd05b6138a56cdf25adf/asset-v1:SkillFactory+ADMIN+2020+type@asset+block/note_2.png) **Список  утилит и команд**

|   |   |
|---|---|
|nmap|Сканирование сети|
|netstat|Мониторинг портов на локальной машине, а также сбор статистики сетевых подключений|
|arp|Протокол для определения адреса|
|scp|Копирование файлов по SSH|
|ssh|Удалённое подключение к устройствам|
|dig|Утилита для проверки DNS|
|ping|Утилита для проверки качества соединения в сетях|