**Сеть** — это группа соединённых между собой хостов (_host_).

Сети делятся на **две группы**, в зависимости от их размеров и назначения.

Существует ЛВС — **локальная вычислительная сеть** (англ. _LAN_, _L__ocal Area Network_).Она является основой для построения сетей любого масштаба, но её отличает то, что все устройства, которые в неё входят, расположены на ограниченной территории. К примеру, если у вас дома есть роутер, к которому подключается несколько устройств, то это локальная сеть, ограниченная только вашим домом.

Вторая группа сетей — ГВС — **глобальная вычислительная сеть**. (англ. _WAN_, _Wide Area Network_), которая не ограничена территориально. Глобальная вычислительная сеть создаётся из нескольких локальных вычислительных сетей. Яркий пример глобальной вычислительной сети — интернет (англ. _Internet_).

Для любой сети есть **общие компоненты**:

- **Сервер** — это компьютер, предоставляющий свои ресурсы для совместного использования.
- **Клиент** — это компьютер, который осуществляет доступ к ресурсам сети, предоставляемым сервером.
- **Среда передачи** — способ соединения узлов сети.

## **Типы сетей**

**Одноранговые сети**(англ. p_eer-to-peer_, _P2P_, равный к равному).
Её особенность в том, что в такой сети все устройства имеют одинаковые права, т.е. каждый компьютер в ней функционирует одновременно и как клиент, и как сервер. Одноранговая сеть может применяться в случае небольшого количества пользователей, и когда вопросы защиты данных не критичны. Пример одноранговой сети — это сеть, которая находится у вас дома, где есть роутер и несколько компьютеров, которыми управляете только вы.

**Сети на основе сервера**. Такие сети функционируют на основе выделенного сервера. **Выделенный сервер** — это сервер, который работает только как сервер и не используется в качестве клиента, оптимизирован для оперативной обработки запросов от клиентов. Это называется **клиент-серверной системой**.

## **Передача данных по сети**
Данные по сети пересылаются отдельными пакетами, потому что передача одного большого файла одной частью очень сильно нагружает работу сети. Т.е. один большой файл данных бьётся на несколько сегментов. Это называется **сегментирование данных**. Физически сети могут состоять из медных проводов — витой пары, или оптоволоконных кабелей. Кабель на основе витых пар представляет собой несколько попарно скрученных изолированных медных проводов в пластиковой оболочке.

В оптоволоконном кабеле информация передаётся световым сигналом, и его главный элемент — прозрачное стекловолокно. Оптоволоконный кабель защищён от помех, а передаваемая информация засекречена, т.к. к такому кабелю невозможно подключиться, потому что после нарушения целостности кабеля передача данных по нему становится невозможной.

## **Пространства имён**
C увеличением количества компьютеров в сети постоянное обращение по _IP_-адресу стало неудобным, поэтому ЭВМ начали присваивать имена.

Для решения этой проблемы в начале 80-х годов была создана **DNS** (_Domain Name System_ — система доменных имён) — система, представляющая распределённую базу данных, в которой хранились имена для преобразования в _IP_-адреса и обратно.

Для этого в _DNS_ было введено такое понятие, как **домен** (_domain_ — административная часть распределённой системы), и то, что каждая машина в сети должна находиться в своём домене.

## **Доменная структура**
Доменная структура является **иерархической**. Все имена начинаются с корневого домена, который обозначается символом «.», и в него уже входят все домены первого уровня. Т.е. по сути «.» является доменом нулевого уровня.

**Домены первого уровня** — это _.ru_, ._com_, ._net_ и т.д., то, что обычно идёт после точки. После этого идут домены второго, третьего и последующих уровней. В _DNS_ есть такое понятие, как **квалификация доменного имени FQDN** (_Fully Qualified Domain Name_ — полностью определённое имя домена), которое говорит о том, что имя должно состоять из двух частей: имени компьютера и имени домена.

К примеру, _blog.skillfactory.ru_ состоит из:

- _blog_ — имени машины, он же доменное имя третьего уровня;
- _skillfactory_ — имени домена, он же домен второго уровня;
- _.ru_ — домена первого уровня.

Но каждый _DNS-_сервер в сети не отвечает за все хосты в сети, поэтому каждый сервер отвечает не за всю сеть, а только за небольшую её часть. Т.е. зона ответственности _DNS_-сервера — это компьютеры в его домене.

## **Принцип работы DNS**

![[Pasted image 20230916092634.png]]

Для того, чтобы понять принцип работы _DNS_, воспользуемся схемой, приведённой выше.

Предположим, что все _DNS_-сервера были включены одновременно и не отвечали ни на один запрос. При этом _DNS_-сервера, отвечающие за определённый домен (на схеме обозначены квадратом), находятся на компьютере с именем этого домена. В реальной жизни _DNS_-сервера могут поддерживать сразу несколько доменов одновременно и располагаться в любом месте сети.

Предположим, вы переходите по некоторому адресу, например, _www.google.com.ua_. Для того, чтобы браузер смог послать пакеты на соответствующий веб-сервер, ему необходимо получить _IP_-адрес этого сервера. Он обратится к клиенту _DNS_, находящемуся на том же компьютере, а клиент обратится к _DNS_-серверу, на работу с которым он настроен.

Допустим, в вашей домашней сети _DNS_-сервер настроен на вашем роутере, и именно на него пошлёт первый запрос клиент (**шаг 1 на схеме**). Но _www.google.com.ua_ не входит в ответственность сервера, который расположен на вашем домашнем роутере. Поэтому в дальнейшем запрос будет направлен к _DNS_-серверу, отвечающему за корневой домен (**шаг 2**). Корневой _DNS_-сервер тоже не отвечает за машины домена _www.google.com.ua_, и не может дать окончательный ответ. Но этот сервер знает _IP_-адрес и имя _DNS_-сервера, отвечающего за домен ._ua_. И он возвращает эти данные нашему серверу (**шаг 3 на схеме**). Следующий запрос будет послан _DNS_-серверу, отвечающему за домен ._ua_ (**шаг 4 на схеме**). Но и он не может дать нам ответ на наш запрос, т.к. не является ответственным за домен _www.google.com.ua_. Но он знает _IP_-адрес и имя _DNS_-сервера, отвечающего за домен _.com.ua_, и возвращает нам эти значения (**шаг 5 на схеме**).

Наш _DNS_-сервер посылает запрос на _DNS_-сервер, отвечающий за домен ._com.ua_ (**шаг 6 на схеме**). Этот _DNS_-сервер не является ответственным за домен _www.google.com.ua_, но ему известны _IP_-адрес и имя _DNS_-сервера, отвечающего за домен _www.google.com.ua_, и он самостоятельно посылает запрос на этот сервер (**шаг 7 на схеме**). Почему он самостоятельно ищет информацию, будет рассказано ниже. Поскольку _DNS_-сервер отвечает за домен _www.google.com.ua_, он возвращает _IP_-адрес машины _www_ (**шаг 8 на схеме**). Этот _IP_-адрес возвращается нашему _DNS_-серверу (**шаг 9**), и он возвращает его клиенту (**шаг 10**).

Если посмотреть на приведённую схему, то можно обратить внимание на различие в поведении _DNS_-серверов 2, 3 и 4. Первые два сервера выдавали информацию только о нижестоящих в иерархии _DNS_-серверах. А сервер 4 сам обратился за информацией к серверу 5. Первые два сервера являются не рекурсивными, а сервер 4 — рекурсивным.

***Рекурсивные сервера*** пытаются самостоятельно выполнить все шаги по получению интересующей информации, ***нерекурсивные*** выдают только информацию о зоне, за которую они отвечают, или информацию, находящуюся в их кэше.

_DNS_-сервера, отвечающие за домены первого и второго уровня, обычно являются нерекурсивными, поскольку им приходиться обрабатывать большое количество запросов. Например, _DNS_-сервера, отвечающие за корневой домен, обрабатывают около 20000 запросов в секунду.

_DNS_-сервер, обозначенный на схеме под номером 4, тоже можно сделать нерекурсивным. Будет ли ваш _DNS_-сервер рекурсивным или нерекурсивным, зависит от того, как вы его настроите.

_DNS_-сервера, обслуживающие запросы клиентов _DNS_, обязательно должны быть рекурсивными для запросов клиентов, поскольку клиенты _DNS_ не понимают пересылок к другим _DNS_-серверам.

_DNS_-сервер, который будет рассматриваться на нашем курсе, позволяет сделать так, что для запросов внутренних клиентов _DNS_ он будет выглядеть как рекурсивный сервер, а для внешних запросов — как нерекурсивный.

Предположим, что _DNS_-сервер, отвечающий за домен _www.google.com.ua_, по каким-либо причинам не доступен. Тогда _DNS_-сервер 4 не сможет получить информацию о машине _www.google.com.ua_, и по истечении некоторого времени, отведённого на запрос, вернёт нам отрицательный ответ — машина _www.google.com.ua_ не существует. Эта информация попадет в кэш нашего сервера, и будет выдана клиенту.

Теперь предположим, что через некоторый промежуток времени _DNS_-сервер, отвечающий за домен _google.com.ua_, станет доступен, и начнёт отвечать на вопросы. Но поскольку информация уже хранится в кэше нашего сервера, в среднем, в течение суток наш сервер будет выдавать отрицательные ответы клиентам.

Чтобы такой ситуации не возникало, рекомендуется использовать дополнительные _DNS_-сервера, поддерживающие ваш домен. На схеме такие сервера обозначены символом _S_. Серверу 4 известны все _DNS_-сервера, отвечающие за домен _google.com.ua_, и если сервер 5 не отвечает на запросы, сервер 4 обратится к другим _DNS_-серверам, ответственным за домен. Сервер 5 называется главным (_master_) _DNS_-сервером. Дополнительные сервера называются подчинёнными (_slave_) _DNS_-серверами. Все изменения в домене описываются только на _master-_сервере — на _slave_-серверах информация непосредственно не редактируется, они получают её с _master_-сервера.

Когда клиент _DNS_ получает информацию с авторитетных серверов — _master_ или _slave_ — этот ответ называется **авторитетным**. Если информация получена из кэш, такой ответ называется **неавторитетным**.

Стоит также отдельно упомянуть о **кэширующих серверах**.

При просмотре сайта с большим количеством изображений, например, социальных сетей (хотя пример грубоват, но допустим, что это так) при использовании старого браузера, не поддерживающего протокол _HTTP_ версии 1.1 (старый _Internet Explorer_ на _Windows_ 98), то на получении каждого изображения будет формироваться отдельный запрос. И если просматривать 100 изображений, то произойдёт и 100 запросов к _DNS_-серверу. Тогда вся процедура преобразования имени в _IP_ и обратно будет повторяться при каждом запросе, то тогда бы весь трафик состоял только из _DNS_-запросов.

Для того, что бы избежать эту проблему, сервер помещает всю информацию о социальной сети, куда вы заходили в свой локальный кэш, и при следующем запросе будет выдавать информацию из него, а не проходить снова весь цикл запроса и преобразования имён. Кроме того, он поместит в кэш ответы и других _DNS_-серверов, через которые проходил запрос. Обычно кэш хранится в течение суток.

## **Подведём итог**

В этом юните рассказывалось, как ходят по сети пакеты и как работает _DNS_, то есть та основа, на которой строится передача данных по сети.