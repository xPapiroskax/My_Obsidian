## **IP**

Протокол _IP_ позволяет определять **местоположение конечного компьютера** в сети.

Если протокол определяет адрес конечного компьютера как адрес в том же сегменте сети (подсети), что и адрес источника, он передает пакет прямо на нужный компьютер. Если адрес назначения не принадлежит тому же сегменту, то протокол _IP_ должен использовать маршрутизаторы, чтобы переслать пакет.

В каждый пакет протокола _IP_ включается _IP_-адрес отправителя и получателя. 

**IP** представляет собой ненадёжный, не требующий установления подключения протокол, который используется для адресации пакетов и их маршрутизации между компьютерами, объединёнными в сеть.   

Протокол _IP_ предотвращает вечное нахождение пакета в сети, ограничивая число сетей, через которые может пройти пакет. Это достигается путем назначения срока жизни _TTL_ (_Time to Live_) для каждого пакета. Параметр _TTL_ определяет максимальное время, которое пакет может провести в сети до своего удаления (максимальное число маршрутизаторов, через которые может пройти пакет).

**IP-адрес** — уникальный идентификатор, однозначно определяющий узел (хост) в сети, использующей стек протоколов _TCP/IP_.

**Узел (_node_) или хост (_host_)** — устройство, которое можно отдельно адресовать в сети, способное взаимодействовать с другими устройствами.

Чтобы протокол _IP_ мог обеспечить межсетевое взаимодействие, т. е. обеспечить обмен информацией между компьютерами, расположенными в разных подсетях большой составной сети, он должен использовать собственную глобальную систему адресации, не зависящую от адресации компьютеров в отдельных сетях.

Эта система должна позволять универсальным и однозначным способом идентифицировать любой компьютер большой составной сети.

Очевидным решением является **уникальная адресация** всех сетей составной сети, а затем адресация всех устройств в пределах каждой из этих сетей.

## **Адресация в сети**

Сетевой адрес, состоящий из номера сети и номера хоста в сети, позволит уникальным образом **идентифицировать каждый хост** в большой составной сети.

_IP_-адрес — 32-х разрядное двоичное число. Для удобства записывается в специальном формате — десятичное с точкой (_dotted decimal_) — _W.X.Y.Z_ — десятичное с точкой.

![[Pasted image 20230913090739.png]]

Для преобразования двоичного формата в десятичный посмотрим такую таблицу:
![[Pasted image 20230913090805.png]]

И для примера возьмём октет 10011001, который будет выглядеть как 128+0+0+16+8+0+0+1=153.

Для наглядности добавлю в таблицу.
![[Pasted image 20230913090830.png]]
Поэтому складываем 128+0+0+16+8+0+0+1 и получаем 153.
![[Pasted image 20230913090852.png]]

**IP-адрес** назначается не по принципу последовательного перечисления хостов, а **разбивается на две части**:

- **Идентификатор сети** (_Network ID_) — определяет физическую сеть. Он одинаков для всех узлов в одной сети и уникален для каждой сети, включённой в объединённую сеть.
- **Идентификатор хоста** (_Host ID_) — соответствует конкретному узлу (компьютеру, маршрутизатору и т.д.) в данной сети.

Идентификатор сети занимает старшую часть _IP_-адреса, идентификатор хоста — младшую. Такое представление _IP_-адреса дает возможность объединять ЛВС в большие составные сети и, наоборот, разбивать большие сети на подсети.

Запись адреса не предусматривает специальных разграничительных символов между номером сети и номером узла. Возникает необходимость при передаче пакета по сети разделять адрес на эти части.

Маршрутизация осуществляется на основании номера сети, поэтому маршрутизаторы, получая пакет, должны читать из соответствующего поля заголовка адрес назначения и выделять из него номер сети. Но для определения, какая часть выведена к номеру сети, а какая — к номеру узла, существует распределение по классам сетей.

Каждый класс сети определяет, какая часть адреса отводится под _ID_ сети, а какая — под _ID_ хоста. Различают **классы сетей**:
![[Pasted image 20230913090922.png]]
Признаком, на основании которого _IP_-адрес относится к тому или иному классу, является **значение нескольких старших бит адреса**.
![[Pasted image 20230913090942.png]]

Также за разделение хостов и сетей отвечают **маски подсети**.

![[Pasted image 20230913091009.png]]

Как узнать, какое количество бит представляет сетевую часть адреса, а какое — хостовую часть? При указании сетевого адреса _IPv4_ вы добавляете длину префикса к сетевому адресу.

**Длина префикса** — это количество бит в адресе, представляющих его сетевую часть. Например, в 172.16.55.87/16, /16 — это длина префикса. Она указывает, что первые 16 бит являются сетевым адресом. Оставшиеся 16 бит, то есть два последних октета, будут хостовой частью.

**Объект, использующийся для определения сетевыми устройствами сетевой части адреса _IPv4_, называют ***маской подсети***.

Маска подсети состоит из 32 битов, как и _IP_-адрес, и использует единицы и нули для указания, какие биты адреса являются битами сетевой части, и какие биты являются битами хостовой части. Маска подсети указывается в том же самом десятичном формате с разделением через точку, что и адрес _IPv4_. Маска подсети создается путём проставления двоичной единицы в каждый бит, представляющий сетевую часть адреса, и размещение двоичного нуля в каждый бит, представляющий хостовую часть. Префикс /16 выражается как маска подсети 255.255.0.0 (11111111.11111111. 00000000.00000000). Оставшиеся младшие биты маски подсети — нули, они указывают на адрес хоста в сети.

Маска подсети настраивается на хосте вместе с адресом _IPv4_ для определения сетевой части этого адреса.

Сети не всегда присваивается один и тот же префикс. В зависимости от числа хостов в сети, присвоенный сетям префикс может быть разным. Наличие другого префикса изменяет диапазон хостов и широковещательный адрес для каждой сети.

Например, рассмотрим хост 10.1.20.70/26.

Адрес:

- 10.1.20.70
- 00001010.00000001.00010100.01000110

Маска подсети:

- 255.255.255.192
- 11111111.11111111.11111111.11000000

Адрес сети:

- 10.1.20.64
- 00001010.00000001.00010100.01000000

А теперь, когда немного разобрались с тем, как устроены _IP_-адрес и маска подсети, то можно перейти к настройке.

## **Настройка IP-адреса**

Как говорилось в прошлом модуле, за настройку адресов отвечают утилиты `IP AD` (сокращённо от `ip address` или `ip addr` — её можно сокращать по-разному) и/или `Ifconfig`.

Стоит рассмотреть пример с утилитой `ip`. Как известно из прошлого модуля, у системы есть интерфейс, и у которого есть определённое имя. И при назначении _IP_-адреса надо указывать имя интерфейса, т.к. интерфейсов может быть несколько.

![[Pasted image 20230913091209.png]]

В этом примере добавляется _IP_-адрес 1.2.3.4 с префиксом 24 на интерфейс _ens160_. Используется команда `add` для добавления. Для удаления же нужно использовать `del`.
![[Pasted image 20230913091225.png]]

Но в данном случае после перезагрузки системы настройки не будут сохранены, поэтому настройками для сетевых интерфейсов занимается утилита `Netplan`.

Файлы конфигурации располагаются в `/etc/netplan/`, где будет находиться файл, помеченный как `yaml` после точки.

Сама структура файла будет выглядеть примерно так:
![[Pasted image 20230913091253.png]]

Где:

- Строка `network:` указывает, что начинаются настройки для сетевых интерфейсов.

- `ethernets` указывает на то, что настройки будут именно для _Ethernet_-адаптеров.
- Следующая после `ethernets` строка — это имя интерфейса, в дальнейшем то, что будет идти после, является настройками для данного интерфейса.
- `dhcp4:` no указывает на то, что не надо принимать настройки по _dhcp_. Может принимать также состояние `yes`. Аналогом могут выступать `true` и `false`. Есть и аналогичный параметр `dhcp6` — работает как `dhcp4`, но только с _IPv6_.
- В строке `addresses:` в квадратных скобках, совместно с префиксом, указывается адрес, который должен быть назначен устройству. В данном примере мы используем только один адрес, но на один интерфейс можно назначать и несколько адресов. Но это будем применять позже, когда будет работа с несколькими серверами.
- В строке `gateway4` указывается основной шлюз для сети. Обычно это первый адрес в сети.
- Далее идёт `nameservers` — конфигурация для серверов имён, где требуется указывать в квадратных скобках через запятую основной и дополнительный _DNS_-сервера.

![[Pasted image 20230913091325.png]]

Работает по клиент-серверной системе, и это одна из причин, зачем нужен сервер в сети.

Когда клиент загружается (или хочет присоединиться к сети), он начинает четырёхэтапный процесс для получения аренды. Он запускает процесс с широковещательным (_broadcast_) сообщением _DHCPDISCOVER_ со своим собственным _MAC_-адресом для обнаружения доступных серверов _DHCPv4_.

Поскольку у клиента нет способа узнать подсеть, к которой он принадлежит, у сообщения _DHCPDISCOVER_ адрес назначения _IPv4-_адреса — 255.255.255.255. А поскольку у клиента ещё нет настроенного адреса _IPv4_, то исходный _IPv4_-адрес — 0.0.0.0.

Сообщение _DHCPDISCOVER_ находит серверы _DHCPv4_ в сети. Поскольку клиент не имеет _IPv4-_информации при загрузке, он использует широковещательные адреса 2 и 3 уровня для связи с сервером.

Когда _DHCPv4_-сервер получает сообщение _DHCPDISCOVER_, он резервирует доступный _IPv4_-адрес для аренды клиенту. Сервер также создаёт запись _ARP_, состоящую из _MAC_-адреса клиента и арендованного _IPv4_-адреса, _DHCP_-сервер отправляет связанное сообщение _DHCPOFFER_ запрашивающему клиенту как одноадресную передачу (_unicast_), используя _MAC_-адрес сервера в качестве исходного адреса и _MAC_-адрес клиента в качестве адреса доставки.

Когда клиент получает _DHCPOFFER_ с сервера, он отправляет обратно сообщение _DHCPREQUEST_. Это сообщение используется как для получения, так и для продления аренды. Когда используется для получения аренды, _DHCPREQUEST_ служит в качестве уведомления о принятии выбранных сервером параметров, которые он предложил, и отклонении предложения от других серверов. Многие корпоративные сети используют несколько _DHCP-_серверов, и сообщение _DHCPREQUEST_ отправляется в виде широковещательной передачи, чтобы информировать все серверы о принятом предложении.

При получении сообщения _DHCPREQUEST_ сервер проверяет информацию об аренде с помощью _ICMP_-запроса на этот адрес, чтобы убедиться, что он уже не используется, и создаёт новую _ARP_-запись для аренды клиента, а затем отвечает одноадресным _DHCPACK_-сообщением. Это сообщение является дубликатом _DHCPOFFER_, за исключением изменения поля типа сообщения. Когда клиент получает сообщение _DHCPACK_, он регистрирует информацию и выполняет поиск _ARP_ для назначенного адреса. Если ответа на _ARP_ нет, клиент знает, что адрес _IPv4_ действителен, и начинает использовать его как свой собственный.

Для применения конфигурации после внесения изменений требуется набрать команду:
![[Pasted image 20230913091414.png]]

Если всё пройдёт без ошибок, то все полученные конфигурации будут применены к сетевому устройству.

**Ошибки, которые могут возникать, заключаются в том, что _YAML_ бывает придирчив к разметке, и лишний пробел может привести к ошибке.

Также мы указывали в конфигурации шлюз. Можно добавлять его и без конфигурации, с помощью утилиты _IP_, но объектом _route_.

## **Утилита IP**

Сейчас стоит подробнее рассказать об утилите `ip`, чтобы не путаться.

Синтаксис такой:

![[Pasted image 20230913091447.png]]

Ключи, которые можно использовать:

> - `-V` —выводит информацию об утилите и версии утилиты.
> - `-s` — выводит больше информации и статистики.
> - `-o` — выводит каждую запись с новой строки.
> - `-r` — выполняет резолв (_resolve_ — преобразование имён в _IP_-адрес и обратно) и выводит символические имена хостов.

Но в данном случае гораздо интереснее объекты:

> - `address` — для работы с сетевыми адресами на устройстве. Тот объект, что использовали для вывода информации и ввода _IP_-адреса.
> - `route` — объект для управления маршрутизацией. Его скоро будем использовать и рассмотрим на примерах.
> - `link` — выводит информацию о физическом устройстве, _MAC-адрес_.
> - `monitor` — как понятно из контекста, для мониторинга состояния устройства.
> - `rule` — управление правилами маршрутизации.

Это не все объекты, но они могут пригодиться в ближайших модулях.

Команды:

> - `add` — добавить.
> - `del` — удалить.
> - `show` — показать (если не указана никакая команда, то по умолчанию используется эта).

На данном этапе этого списка команд будет достаточно.

Для того, чтобы добавить маршрут по умолчанию, следует использовать следующий синтаксис:

![[Pasted image 20230913091533.png]]

То есть с помощью утилиты `ip` мы изменяем маршруты (`route`) добавлением (`add`) маршрута по умолчанию (`default`) через указанный адрес (via 1.2.3.1).

Чтобы, допустим, удалить этот маршрут, требуется использовать `del`.
![[Pasted image 20230913091602.png]]

Это требуется для того, чтобы компьютер мог общаться с устройствами в других сетях. Для общения с устройствами, которые находятся в этой же сети, маршрут по умолчанию — шлюз, не нужен.

## **Маршруты**

Каждое устройство в сети должно иметь уникальное имя. Это может быть _IP_-адрес, про который уже было сказано. Это также может быть локальный, или аппаратный адрес, который называется _MAC_-адрес. (_MAC_— _Media Access Control_ —  управление доступом к среде). Это адрес, который присваивается непосредственно сетевому адаптеру на заводе производителя. Локальный он потому, что действует не во всех сетях, а только в пределах одной локальной подсети. Внутри одной сети хосты устанавливают связь между собой по канальному уровню модели _OSI_, используя эти адреса.

Также устройство в сети может иметь имя _DNS_, или — ещё один вариант — это _NetBIOS,_ имя, которое может присваиваться устройству только внутри локальной сети.

***Маршрутом*** **называют путь, по которому пакеты ходят от отправителя к получателю. Маршрут определяет не полный путь, а только часть пути от хоста до шлюза.

Т.е. в примере выше был указан для устройства шлюз по умолчанию. Если пакету требуется уйти в другие сети, но он не будет знать, куда конкретно идти, потому что не знает других сетей, то все запросы будет отправлять на шлюз по умолчанию. А уже этот шлюз будет решать, куда отправить пакет.

### **Типы маршрутов**

- Маршрут до хоста — указывается шлюз, на который требуется переслать пакет к **определённому** хосту в другой сети.
- Маршрут к сети — указывается шлюз, на который требуется переслать пакет другому хосту в указанной сети. Т.е., в отличие от предыдущего определения, указывается не один маршрут, а вся сеть, где находится хост. А к какому именно в этой сети устройству требуется передать пакет, будет указано в заголовках пакета.
- Маршрут по умолчанию — указывается шлюз как в примере. Т.е. все пакеты, для которых не определён путь, которым они должны пройти, будут отправляться в этот шлюз.

Все маршруты хранятся в таблице маршрутизации. Для того, чтобы посмотреть таблицу маршрутизации на устройстве с помощью утилиты `ip`, то можно применить следующую команду:

![[Pasted image 20230913091738.png]]

После чего будет выведена таблица, указывающая, кто и куда должен идти.

Сейчас мы рассматриваем их только для ознакомления, что такое бывает и существует, а не для прямой работы с ними. Работать с таблицами маршрутизации глубже мы будем, когда начнётся работа с несколькими серверами.

### **Определение маршрутов**

**Определение маршрутов** служит для того, чтобы определить достижимость другой сети с определённого хоста и шлюз отправки пакетов в удалённые сети. При получении пакета шлюз сверяется с таблицей маршрутизации, находит следующий узел для маршрута пакета, и отправляет пакет уже этому узлу. Если маршрут не находится, то отправляет обратно сообщение, что для данного узла не определён маршрут.

Но случается иногда так, что в глобальной сети существует петля, т.е. пакет будет ходить по кругу, не достигая требуемого хоста. Если это случится, то он мог бы остаться в сети навсегда, и весь трафик состоял бы из таких заблудившихся пакетов. Напомню, что для предотвращения этого существует _TTL_ (_Time To Live_ — время жизни). Это то, сколько раз пакет может совершить прыжков от шлюза к шлюзу. Если количество прыжков превышает _TTL_, то пакет самоустраняется. _TTL_ — это определённое число, и каждый шлюз уменьшает это число для пакета на 1.

### **Виды маршрутизации:**

- **Статическая** — это как раз тот случай, что мы рассматривали — когда вводим маршруты руками с помощью утилиты _ip_.
- **Динамическая** — это когда таблицы маршрутизации сетей обновляются автоматически, с помощью специальных служб. Эти службы непрерывно получают информацию присылаемую другими такими же службами в сети и обновляют таблицу в соответствии с новыми данными.

## **Шлюз**

Шлюз (_Gate_) — это один из типов маршрутизаторов. Они соединяют сети и выполняют функцию маршрутизации пакетов.

**Пример.**

Представим, что вы идёте в лабиринте улиц какого-то сильно запутанного города, и у вас есть только адрес назначения, написанный на бумажке, но где он точно находится, вы не знаете. И на каждом перекрёстке есть ворота, которыми управляет человек. Вы к нему подходите и показываете эту бумажку с адресом, и спрашиваете, куда идти дальше. Человек открывает определённые ворота, и говорит, что на следующем перекрёстке нужно попросить такого же человека, чтобы он открыл нужные ворота. И так будет продолжаться до места назначения.

Вот так и работает маршрутизация в сетях.

Если пакет не доходит до определённого узла, то можно провести диагностику с помощью команды `tracepath`.

Синтаксис такой:
![[Pasted image 20230913091817.png]]

Эта утилита покажет все **прыжки** (в терминологии они называются **хопами**, от _hop_ — прыжок) пакета, и вернёт адреса всех шлюзов, через которые он прошёл. Если пакет не может дойти до места назначения, то покажет последний шлюз, на котором он остановился, а также время прохождения шлюза.

## **Подведём итог**

В этом юните вы получили много информации о сетях, но это только самая верхушка айсберга. Сети связи, опутывающие наш мир, обширны, благодаря им ускорился обмен информации между людьми, и мы вступили в новый век, в будущее. Теперь это неотъемлемая часть жизни, и каждый день вы по многу раз с ними работаете.

Все дальнейшие модули будут неотрывно с ними связаны, и у вас будет появляться больше понимания, как с ними работать.

## **Список утилит и команд**
|   |   |
|---|---|
|`ip`|Утилита для настройки сети|
|`netplan`|Утилита конфигурации сети|
|`tracepath`|Команда диагностики маршрутов|